### 高并发
1. 锁优化

2. java虚拟机对锁的优化

3. 无锁

4. 解决死锁

   1. ##### **锁优化**
      1. 减少锁持有的时间（减少同步的代码，不用同步的就不同步）

      2. 减小锁粒度（比如一个HashMap被划分成16端，数据要插入那段就获取那段的表）

      3. 读写分离锁来替换独占锁

      4. 锁分离（比如链表，在表头加数据和在表尾加数据是不影响的，可以使用两把锁，分别给这2个写操作持有）

      5. 锁粗化（把多个锁的请求和成一个锁）

        ```
         //本来要2个synchronized来给代码加锁，但是为少锁的请求消耗性能，所以整合成一个锁
         public void demoMethod(){
      	      synchronized(lock){
      		  //同步的代码
      		  //不需要同步的代码，但是为了整合成一个锁，也把他加进来
      		  //同步的代码
      	        }
            }
        ```

         ```
           for(int i=0;i<10;i++){
             synchronized(lock){}
            }
            //改成,减少锁的请求次数
            synchronized(lock){
            for(int i=0;i<10;i++){}
            }
         ```
      
   2. **java虚拟机对锁的优化**

      - 锁偏向（默认开启，java虚拟机参数 -XX:-UseBiasedLocking 开启）

        无实际竞争，且将来只有第一个申请锁的线程会使用锁时将会使用，偏向锁只有初始化时需要一次CAS。

        缺点：如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。

        
      
      - 轻量级锁
      
        无实际竞争，多个线程交替使用锁；允许短时间的锁竞争是会开启使用。轻量级锁每次申请、释放锁都至少需要一次CAS。
      
        
      
      - 自旋锁（使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。）
      
        锁膨胀后，为避免线程真实挂起，虚拟机会让当前线程做几个空for循环后，如果还不能获得锁就会挂起
      
        
      
      - 重量级锁
      
        有实际竞争，且锁竞争时间长。
      
        如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。
      
        
      
      - 锁消除
      
        java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。
      
   3. **无锁**

      对于并发而言，锁是一种悲观的策略。而无锁是一种乐观的策略。

      - 比较交换（CAS）

        CAS需要你额外给给出一个期望值。如果变量不是这样，那说明被人修改过。你需要重新读取，再次尝试修改。

      - 无锁的线程安全整数 AtomicInteger

        对其的任何修改都是用CAS指令的

      - 无锁线程安全数组 AtomicIntegerArray

   4. **解决死锁**

      使用jps命令得到java进程的教程ID，接着使用jstack命令得到线程的线程堆栈，然后在屏幕上找到Found one Java-level deadlock：

